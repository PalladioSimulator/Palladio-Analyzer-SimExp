/*
 * This simple QVTO SimuLizar reconfiguration rule increases the processing rate of all
 * resources in case the monitored mean response time is greater than 3.0 (seconds). 
 *
 */

/*
 * Two modeltypes are declared. The http NS URIs correspond to those used to register the 
 * Ecore models in the environment. Alternatively, a workspace metamodel may be used 
 * in conjunction with mappings defined in the project properties.
 */
modeltype PRM uses 'http://simulizar.palladiosimulator.org/RuntimeMeasurement/1.0';
modeltype PCM_ALLOC uses 'http://palladiosimulator.org/PalladioComponentModel/Allocation/5.2';
modeltype PCM_REP uses 'http://palladiosimulator.org/PalladioComponentModel/Repository/5.2';
modeltype PCM_SEFF uses 'http://palladiosimulator.org/PalladioComponentModel/SEFF/5.2';
modeltype PCM_SYS uses 'http://palladiosimulator.org/PalladioComponentModel/System/5.2';
modeltype PCM_RES_ENV uses 'http://palladiosimulator.org/PalladioComponentModel/ResourceEnvironment/5.2';
modeltype PCM_RES_TYPE uses 'http://palladiosimulator.org/PalladioComponentModel/ResourceType/5.2';
modeltype PCM_USAGE uses 'http://palladiosimulator.org/PalladioComponentModel/UsageModel/5.2';
modeltype PCM_FEATURE_CONF uses 'http://sdq.ipd.uka.de/FeatureConfig/2.0';
modeltype PCM_FEATURE_MOD uses 'http://sdq.ipd.uka.de/FeatureModel/2.0';
modeltype PCM_CORE uses 'http://palladiosimulator.org/PalladioComponentModel/Core/5.2';
modeltype PCM_COMP uses 'http://palladiosimulator.org/PalladioComponentModel/Core/Composition/5.2';
modeltype PCM_ENTITY uses 'http://palladiosimulator.org/PalladioComponentModel/Core/Entity/5.2';
modeltype PCM_PARAM uses 'http://palladiosimulator.org/PalladioComponentModel/Parameter/5.2';
modeltype PCM_STOEX uses 'http://sdq.ipd.uka.de/StochasticExpressions/2.2';
modeltype PCM_FAILURESCENARIO uses 'http://palladiosimulator.org/failurescenario/1.0';

/*
 * The transformation signature declares that a PRM modeltype is required as input, while an PCM
 * modeltype is transformed inplace. The PRM modeltype is referenced as 'prm' throughout the 
 * transformation definition, while no name is needed for the output PCM modeltype. Note that OCL 
 * type and namespace notation are used in operational QVT (: and :: respectively).
 */
 
 
 /**
 *	Scaling: is the property of a system to handle a growing amount of work by adding resources to the system.
 *
 * - horizontal scaling (scale out/in): 
 	-> adding more nodes to (or removing nodes from) a system, such as adding
 	   a new computer to a distributed software application
 *
 * - vertical scaling (scale up/down): 
 * 	 -> adding resources to (or removing resources from) a single node,
 *      typically involving the addition of CPUs, memory or storage to a single computer
 */ 
 
transformation scaleIn(in pcmAllocation : PCM_ALLOC) {
							

	/**
	 * The main transformation.
	 * This is the entry point to the overall transformation.
	 */
	main() {
	

		log('Transformation rule [scaleIn] started ...');
		
		/**
		*	implement transformation logic 
		
		* we start with a very simple scaleIn logic
		* we assume, that all nodes have the same deployment, i.e.
		* all nodes have the same deploymed components
		* scaleIn in this setup means, that we set the
		* branch probability to 0.0 for those nodes,
		* that should be removed from the current simulation
		*
		* a more complex logic should then address the relocation
		* of componentes, as well as the removal (or marking as unavailable)
		* of resource containers by e.g. removing the deployment in the assembly context
		*
		* Additionally if we assume, that the deployment differs from node to node,
		* you need also take into account the existence of a component before
		* switching.  
		*/
		
		assert fatal(pcmAllocation.rootObjects()[Allocation]->size() > 0)
			with log ("Allocation Model is empty!");
			
		
		pcmAllocation.rootObjects()[Allocation]->forAll(
					allocation : Allocation | 
					outSourceProcessing(allocation.allocationContexts_Allocation)
		);
		
		log('Transformation rule [scaleIn] DONE.');
	}
	
	
		/**
	 * outsource Processing.
	 */
	helper outSourceProcessing(allocationContexts : Set(AllocationContext)) : Boolean {
	
	log('Found ' +  allocationContexts->size().toString() + ' AllocationContexts');
	
		allocationContexts->forEach(allocation){

			if( allocation.assemblyContext_AllocationContext.id = "_6F6LYAEnEeS7FKokKTKFow" ) {
			log('found load balancer: AC_LoadBalancer');
				allocation.assemblyContext_AllocationContext.encapsulatedComponent__AssemblyContext.oclAsType(BasicComponent).serviceEffectSpecifications__BasicComponent->forEach(seff) {
					if(seff.oclIsTypeOf(ResourceDemandingSEFF)) {
						//name of branch: delegateToServer2
						var branch2 : ProbabilisticBranchTransition = seff.allSubobjects()[ProbabilisticBranchTransition]->any(id="_tjFukAEoEeS7FKokKTKFow");
						if(branch2.branchProbability > 0.0) {
							branch2.branchProbability := 0.0.max(branch2.branchProbability - outsourceFactor);
							log('Set branchProbability to ' + branch2.branchProbability.toString());
							return true;
						};
						//name of branch: delegateToServer1
						var branch1 : ProbabilisticBranchTransition = seff.allSubobjects()[ProbabilisticBranchTransition]->any(id="_ridTkAEoEeS7FKokKTKFow");
						if(branch1.branchProbability < 1.0) {
							branch1.branchProbability := 1.0.max(branch1.branchProbability + outsourceFactor);
							log('Set branchProbability to ' + branch1.branchProbability.toString());
							return true;
						}
					}
				}
			}
		};
		
		return false;
	}

}