grammar org.palladiosimulator.simexp.dsl.smodel.Smodel with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate smodel "http://www.palladiosimulator.org/simexp/dsl/smodel/smodel"

Smodel:
	'modelName' '=' modelName=STRING ';'
	(constants+=Constant |
	 variables+=Variable |
	optimizables+=Optimizable  ';' |
	envVariables+=EnvVariable |
	probes+=Probe)*
	actions+=Action*
	statements+=IfStatement*
	;
	
Field:
	InternalField | ExternalField
	;
	
InternalField:
	Constant | Variable | Parameter
;

ExternalField:
	Optimizable | EnvVariable | Probe
;

Constant:
	'const' dataType=PrimitiveType name=ID '=' value=DisjunctiveExpr ';'
	;

Variable:
	'var' dataType=PrimitiveType name=ID '=' value=DisjunctiveExpr ';'
	;

Parameter:
	'param' dataType=PrimitiveType name=ID
	;

Optimizable:
	'optimizable' dataType=PrimitiveType values=Bounds name=ID
	;

EnvVariable:	
	'envvar' dataType=PrimitiveType name=ID ':' 'variableId' '=' variableId=STRING  ';'
	;

Probe:
	'probe' dataType=PrimitiveType name=ID ':' kind=ProbeAdressingKind '=' identifier=STRING ';'
	;

enum ProbeAdressingKind:
    MONITORID='monitorId' | ID='id'
    ;

Bounds:
	{Array} '{' (values+=Literal (',' values+=Literal)*) '}' |
	{Range} '[' startValue=Literal ',' endValue=Literal ',' stepSize=Literal ']'
	;

Action: 
	'action' name=ID '(' parameterList=ParameterList ')' ';'
	;

ParameterList: 
	{ParameterList}
	(((parameters+=Parameter (',' parameters+=Parameter)* (',' optimizables+=Optimizable)*)) |
	(optimizables+=Optimizable (',' optimizables+=Optimizable)*))?
	;

Statement:
	ActionCall | IfStatement
	;

ActionCall returns Statement:
	{ActionCall} 
	actionRef=[Action] '(' (arguments+=ArgumentKeyValue (',' arguments+=ArgumentKeyValue)*)? ')' ';'
	;

ArgumentKeyValue:
	paramRef=[Parameter] '=' argument=DisjunctiveExpr
	;

IfStatement returns Statement: 
	{IfStatement}
	'if' '(' condition=DisjunctiveExpr ')' '{' (thenStatements+=Statement)* '}'
	(withElse?='else' '{' (elseStatements+=Statement)* '}')?
	;

DisjunctiveExpr returns Expression:
    ConjunctiveExpr ({Expression.left=current} op=DisjunctiveOp right=ConjunctiveExpr)*
    ;

ConjunctiveExpr returns Expression:
	EquativeExpr ({Expression.left=current} op=ConjunctiveOp right=EquativeExpr)*
	;

EquativeExpr returns Expression:
	RelationalExpr ({Expression.left=current} op=EquativeOp right=RelationalExpr)*
	;

RelationalExpr returns Expression:
	AdditiveExpr ({Expression.left=current} op=RelativeOp right=AdditiveExpr)?
	;

AdditiveExpr returns Expression:
	MultiplicativeExpr ({Expression.left=current} op=AdditiveOp right=MultiplicativeExpr)*
	;

MultiplicativeExpr returns Expression:
	UnaryExpr ({Expression.left=current} op=MultiplicativeOp right=UnaryExpr)*
	;

UnaryExpr returns Expression:
	op=UnaryOp? left=Term
	;

Term returns Expression:
	(fieldRef=[Field] | literal=Literal | '(' left=DisjunctiveExpr ')')
	;

Literal:
	{BoolLiteral} true=BOOL |
	{IntLiteral} value=INT |
	{FloatLiteral} value=FLOAT |
	{StringLiteral} value=STRING
	;

enum PrimitiveType returns DataType: 
	BOOL = 'bool' | INT = 'int' | FLOAT = 'float' | STRING = 'string'
	;

// Rule 'Operation' is not used, but is necessary to provide a default value for operations.
enum Operation: UNDEFINED;
enum DisjunctiveOp returns Operation: OR = '||';
enum ConjunctiveOp returns Operation: AND = '&&';
enum EquativeOp returns Operation: EQUAL = '==' | UNEQUAL = '!=';
enum RelativeOp returns Operation: SMALLER = '<' | SMALLER_OR_EQUAL = '<=' | GREATER_OR_EQUAL = '>=' | GREATER = '>';
enum AdditiveOp returns Operation: PLUS = '+' | MINUS = '-';
enum MultiplicativeOp returns Operation: MULTIPLY = '*' | DIVIDE = '/' | MODULO = '%';
enum UnaryOp returns Operation: PLUS = '+' | MINUS = '-' | NOT = '!';

terminal BOOL returns ecore::EBoolean: 'true' | 'false';
terminal FLOAT returns ecore::EFloat: 
	((INT)? '.' INT (('e' | 'E') ('-')? INT)?) | (INT ('e' | 'E') ('-')? INT)
	;
