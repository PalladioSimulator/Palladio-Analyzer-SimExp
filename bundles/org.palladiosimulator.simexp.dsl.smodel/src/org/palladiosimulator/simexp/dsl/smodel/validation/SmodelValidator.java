/* generated by Xtext 2.26.0
 */
package org.palladiosimulator.simexp.dsl.smodel.validation;

import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.ValidationMessageAcceptor;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Action;
import org.palladiosimulator.simexp.dsl.smodel.smodel.ActionCall;
import org.palladiosimulator.simexp.dsl.smodel.smodel.ArgumentKeyValue;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Array;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Bounds;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Constant;
import org.palladiosimulator.simexp.dsl.smodel.smodel.DataType;
import org.palladiosimulator.simexp.dsl.smodel.smodel.EnvVariable;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Expression;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Field;
import org.palladiosimulator.simexp.dsl.smodel.smodel.IfStatement;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Literal;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Operation;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Optimizable;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Parameter;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Probe;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Range;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Smodel;
import org.palladiosimulator.simexp.dsl.smodel.smodel.SmodelPackage;
import org.palladiosimulator.simexp.dsl.smodel.smodel.Variable;
import org.palladiosimulator.simexp.dsl.smodel.util.SmodelDataTypeSwitch;

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class SmodelValidator extends AbstractSmodelValidator {

    private final SmodelDataTypeSwitch typeSwitch;

    public SmodelValidator() {
        super();
        this.typeSwitch = new SmodelDataTypeSwitch();
    }

    @Check
    public void checkKmodel(Smodel model) {
        String modelName = model.getModelName();
        if (modelName == null) {
            warning("No modelName given.", model, SmodelPackage.Literals.SMODEL__MODEL_NAME);
        } else {
            if (modelName.isEmpty()) {
                warning("Empty modelName.", model, SmodelPackage.Literals.SMODEL__MODEL_NAME);
            }
        }

        checkDuplicateIds("probe", model.getProbes(), Comparator.comparing(Probe::getKind)
            .thenComparing(Probe::getIdentifier));
        checkDuplicateIds("envvar", model.getEnvVariables(), Comparator.comparing(EnvVariable::getVariableId));

        checkUnusedFields(model.getConstants());
        checkUnusedFields(model.getVariables());
        checkUnusedFields(model.getOptimizables());
        checkUnusedFields(model.getEnvVariables());
        checkUnusedFields(model.getProbes());

        List<Action> actions = model.getActions();
        for (int i = 0; i < actions.size(); i++) {
            Action action = actions.get(i);
            Collection<EStructuralFeature.Setting> actionReferences = EcoreUtil.UsageCrossReferencer.find(action,
                    action.eResource());

            if (actionReferences.isEmpty()) {
                warning("The action '" + action.getName() + "' is never used.", SmodelPackage.Literals.SMODEL__ACTIONS,
                        i);
            }
        }
    }

    private void checkUnusedFields(List<? extends Field> fields) {
        ListIterator<? extends Field> iter = fields.listIterator();
        while (iter.hasNext()) {
            int index = iter.nextIndex();
            Field field = iter.next();
            Resource resource = field.eResource();
            Collection<EStructuralFeature.Setting> fieldReferences = EcoreUtil.UsageCrossReferencer.find(field,
                    resource);

            if (fieldReferences.isEmpty()) {
                EStructuralFeature feature = field.eContainmentFeature();
                warning(String.format("The %s '%s' is never used.", field.eClass()
                    .getName(), field.getName()), feature, index);
            }
        }
    }

    private <T extends Field> void checkDuplicateIds(String type, List<T> fields, Comparator<T> comparator) {
        Set<T> duplicates = findDuplicates(fields, comparator);
        for (T duplicate : duplicates) {
            EStructuralFeature feature = duplicate.eContainmentFeature();
            error(String.format("%s '%s' duplicate addressing.", type, duplicate.getName()), feature);
        }
    }

    private <T> Set<T> findDuplicates(List<T> fields, Comparator<T> comparator) {
        Set<T> items = new TreeSet<>(comparator);
        return fields.stream()
            .filter(n -> !items.add(n))
            .collect(Collectors.toSet());
    }

    @Check
    public void checkConstant(Constant constant) {
        Set<Field> allFieldReferences = getAllFieldReferences(constant);

        if (containsNonConstantFieldReference(allFieldReferences)) {
            error("Cannot assign an expression containing a non-constant value to a constant.",
                    SmodelPackage.Literals.CONSTANT__VALUE);
            return;
        }
        if (containsCyclicReferences(constant, allFieldReferences)) {
            error("Cyclic reference detected.", constant, SmodelPackage.Literals.CONSTANT__VALUE);
        }

        Expression expression = constant.getValue();
        if (allFieldReferences.size() == 1) {
            if (expression.getOp() == Operation.UNDEFINED) {
                warning("Constant '" + constant.getName() + "' is probably redundant.",
                        SmodelPackage.Literals.CONSTANT__VALUE);
            }
        }

        if (expression != null) {
            DataType constantDataType = getDataType(constant);
            DataType valueDataType = getDataType(expression);
            if (!checkTypes(constantDataType, valueDataType, SmodelPackage.Literals.CONSTANT__VALUE)) {
                return;
            }
        }
    }

    @Check
    public void checkVariable(Variable variable) {
        Set<Field> allFieldReferences = getAllFieldReferences(variable);
        if (containsNonConstantFieldReference(allFieldReferences)) {
            error("Cannot assign an expression containing a non-constant value to an variable.",
                    SmodelPackage.Literals.VARIABLE__VALUE);
            return;
        }

        Expression expression = variable.getValue();
        if (expression != null) {
            DataType constantDataType = getDataType(variable);
            DataType valueDataType = getDataType(expression);
            if (!checkTypes(constantDataType, valueDataType, SmodelPackage.Literals.VARIABLE__VALUE)) {
                return;
            }
        }
    }

    private boolean containsCyclicReferences(Field field, Set<Field> allFieldReferences) {
        for (Field refrerredField : allFieldReferences) {
            Set<Field> others = getAllFieldReferences(refrerredField);
            if (others.contains(field)) {
                return true;
            }
        }
        return false;
    }

    private Set<Field> getAllFieldReferences(Field field) {
        Expression expression = getValueExpression(field);
        if (expression == null) {
            return Collections.emptySet();
        }
        return getAllFieldReferences(expression);
    }

    private Expression getValueExpression(Field field) {
        if (field instanceof Constant) {
            Constant constant = (Constant) field;
            return constant.getValue();
        }
        if (field instanceof Variable) {
            Variable variable = (Variable) field;
            return variable.getValue();
        }
        if (field instanceof Probe) {
            return null;
        }
        throw new RuntimeException("Field not supported: " + field);
    }

    private Set<Field> getAllFieldReferences(Expression expression) {
        if (expression == null) {
            return Collections.emptySet();
        }

        Set<Field> fieldReferences = new HashSet<>();
        Field field = expression.getFieldRef();
        if (field != null) {
            fieldReferences.add(field);
        }

        Expression left = expression.getLeft();
        Expression right = expression.getRight();

        Set<Field> leftFieldReferences = getAllFieldReferences(left);
        Set<Field> rightFieldReferences = getAllFieldReferences(right);

        fieldReferences.addAll(leftFieldReferences);
        fieldReferences.addAll(rightFieldReferences);

        return fieldReferences;
    }

    @Check
    public void checkOptimizable(Optimizable variable) {
        DataType dataType = getDataType(variable);
        Bounds bounds = variable.getValues();

        if (bounds != null) {
            if (!compatibleTypes(DataType.FLOAT, dataType) && bounds instanceof Range) {
                error("Cannot assign a range to a variable of the type '" + dataType + "'.",
                        SmodelPackage.Literals.OPTIMIZABLE__VALUES);
            }
        }
    }

    @Check
    public void checkArray(Array array) {
        DataType dataType = getDataType(array);
        List<Literal> values = array.getValues();

        for (int i = 0; i < values.size(); i++) {
            DataType valueType = getDataType(values.get(i));
            checkTypes(dataType, valueType, SmodelPackage.Literals.ARRAY__VALUES, i);
        }
    }

    @Check
    public void checkRange(Range range) {
        DataType dataType = getDataType(range);
        Literal startValue = range.getStartValue();
        Literal endValue = range.getEndValue();
        Literal stepSize = range.getStepSize();

        if (startValue != null) {
            DataType startValueType = getDataType(startValue);
            checkTypes(dataType, startValueType, SmodelPackage.Literals.RANGE__START_VALUE);
        }

        if (endValue != null) {
            DataType endValueType = getDataType(endValue);
            checkTypes(dataType, endValueType, SmodelPackage.Literals.RANGE__END_VALUE);
        }

        if (stepSize != null) {
            DataType stepSizeType = getDataType(stepSize);
            checkTypes(dataType, stepSizeType, SmodelPackage.Literals.RANGE__STEP_SIZE);
        }
    }

    @Check
    public void checkIfStatement(IfStatement ifStatement) {
        Expression condition = ifStatement.getCondition();

        if (condition != null) {
            DataType conditionType = getDataType(condition);
            checkTypes(DataType.BOOL, conditionType, SmodelPackage.Literals.IF_STATEMENT__CONDITION);
        }
    }

    @Check
    public void checkActionCall(ActionCall actionCall) {
        Action action = actionCall.getActionRef();

        if (action != null) {
            List<ArgumentKeyValue> arguments = actionCall.getArguments();
            List<Parameter> parameters = action.getParameterList()
                .getParameters();

            if (arguments.size() != parameters.size()) {
                error("Expected " + parameters.size() + " arguments, got " + arguments.size() + " instead.",
                        SmodelPackage.Literals.ACTION_CALL__ARGUMENTS);
                return;
            }

            for (int i = 0; i < arguments.size(); i++) {
                Field parameter = parameters.get(i);
                ArgumentKeyValue argument = arguments.get(i);

                if (!argument.getParamRef()
                    .equals(parameter)) {
                    error("Arguments must be provided in the order as declared.",
                            SmodelPackage.Literals.ACTION_CALL__ARGUMENTS, i);
                    return;
                }

                DataType parameterType = getDataType(parameter);
                DataType argumentType = getDataType(argument);
                checkTypes(parameterType, argumentType, SmodelPackage.Literals.ACTION_CALL__ARGUMENTS, i);
            }
        }
    }

    @Check
    public void checkExpression(Expression expression) {
        Operation operation = expression.getOp();

        DataType leftType = null;
        if (expression.getLeft() != null) {
            leftType = getDataType(expression.getLeft());
        }

        DataType rightType = null;
        if (expression.getRight() != null) {
            rightType = getDataType(expression.getRight());
        }

        switch (operation) {
        case UNDEFINED:
            break;

        case OR:
        case AND:
        case NOT:
            checkTypes(DataType.BOOL, leftType, SmodelPackage.Literals.EXPRESSION__LEFT);
            if (rightType != null) {
                checkTypes(DataType.BOOL, rightType, SmodelPackage.Literals.EXPRESSION__RIGHT);
            }
            break;

        case EQUAL:
        case UNEQUAL:
            if (leftType == DataType.FLOAT || rightType == DataType.FLOAT) {
                checkTypes(DataType.FLOAT, leftType, SmodelPackage.Literals.EXPRESSION__LEFT);
                checkTypes(DataType.FLOAT, rightType, SmodelPackage.Literals.EXPRESSION__RIGHT);
            } else {
                checkTypes(rightType, leftType, SmodelPackage.Literals.EXPRESSION__LEFT);
                checkTypes(leftType, rightType, SmodelPackage.Literals.EXPRESSION__RIGHT);
            }
            break;

        case SMALLER:
        case SMALLER_OR_EQUAL:
        case GREATER_OR_EQUAL:
        case GREATER:
        case PLUS:
        case MINUS:
        case MULTIPLY:
        case DIVIDE:
        case MODULO:
            checkTypes(DataType.FLOAT, leftType, SmodelPackage.Literals.EXPRESSION__LEFT);
            if (rightType != null) {
                checkTypes(DataType.FLOAT, rightType, SmodelPackage.Literals.EXPRESSION__RIGHT);
            }
            break;

        default:
            throw new RuntimeException("Cannot validate expression with operation '" + operation + "'.");
        }
    }

    private DataType getDataType(EObject object) {
        return typeSwitch.doSwitch(object);
    }

    private boolean checkTypes(DataType expected, DataType actual, EStructuralFeature feature) {
        return checkTypes(expected, actual, feature, ValidationMessageAcceptor.INSIGNIFICANT_INDEX);
    }

    private boolean checkTypes(DataType expected, DataType actual, EStructuralFeature feature, int index) {
        /*
         * Null only occurs in unresolved field references, or when an expression isn't complete. In
         * this cases, no error message regarding the type should be shown.
         */
        if (actual == null) {
            return false;
        }

        if (!compatibleTypes(expected, actual)) {
            StringBuilder errorMessage = new StringBuilder("Expected a value of type '");

            if (expected == DataType.FLOAT) {
                errorMessage.append(DataType.INT + "' or '" + DataType.FLOAT);
            } else {
                errorMessage.append(expected);
            }

            errorMessage.append("', got '" + actual + "' instead.");

            error(errorMessage.toString(), feature, index);

            return false;
        }

        return true;
    }

    private boolean compatibleTypes(DataType expected, DataType actual) {
        return expected == actual || isSubtypeOf(expected, actual);
    }

    private boolean isSubtypeOf(DataType supertype, DataType subtype) {
        return supertype == DataType.FLOAT && subtype == DataType.INT;
    }

    private boolean containsNonConstantFieldReference(Set<Field> fields) {
        for (Field field : fields) {
            if (!(field instanceof Constant)) {
                return true;
            }
        }
        return false;
    }
}
