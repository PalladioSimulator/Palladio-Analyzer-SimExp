package org.palladiosimulator.simexp.markovian.exploitation;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

import org.palladiosimulator.simexp.markovian.access.MarkovModelAccessor;
import org.palladiosimulator.simexp.markovian.activity.Policy;
import org.palladiosimulator.simexp.markovian.exploration.RandomizedStrategy;
import org.palladiosimulator.simexp.markovian.model.markovmodel.markoventity.Action;
import org.palladiosimulator.simexp.markovian.model.markovmodel.markoventity.MarkovEntityFactory;
import org.palladiosimulator.simexp.markovian.model.markovmodel.markoventity.MarkovModel;
import org.palladiosimulator.simexp.markovian.model.markovmodel.markoventity.State;
import org.palladiosimulator.simexp.markovian.model.markovmodel.markoventity.Transition;

public class ProbabilityBasedActionPolicy<T, R> implements Policy<T, Double, Action<Double>> {

    private final static String POLICY_NAME = "ProbabilityBasedActionSelection";

    private final Optional<MarkovModelAccessor<T, Double, R>> markovAccessor;

    public ProbabilityBasedActionPolicy(Optional<MarkovModel<T, Double, R>> markovModel) {
        if (markovModel.isPresent()) {
            MarkovModel<T, Double, R> model = markovModel.get();
            MarkovModelAccessor<T, Double, R> accessor = MarkovModelAccessor.of(model);
            this.markovAccessor = Optional.of(accessor);
        } else {
            this.markovAccessor = Optional.empty();
        }
    }

    @Override
    public String getId() {
        return POLICY_NAME;
    }

    @Override
    public Action<Double> select(State<T> source, Set<Action<Double>> options) {
        if (markovAccessor.isPresent()) {
            return selectAccordingToModel(source, options);
        }
        return selectRandomly(options);
    }

    private Action<Double> selectAccordingToModel(State<T> source, Set<Action<Double>> options) {
        ProbabilityBasedTransitionPolicy probabilityBasedTransitionPolicy = new ProbabilityBasedTransitionPolicy();
        Set<Transition<T, Double>> filterTransitions = filterTransitions(source, options);
        Transition<T, Double> s = probabilityBasedTransitionPolicy.select(null, filterTransitions);
        Action<Double> label = s.getLabel();
        return label.getAction();
    }

    private Set<Transition<T, Double>> filterTransitions(State<T> source, Set<Action<Double>> options) {
        Set<Transition<T, Double>> results = new HashSet<>();
        for (Action<Double> each : options) {
            // TODO exception handling
            MarkovModelAccessor<Double> markovModelAccessor = markovAccessor.get();
            Action<Double> tempAction = MarkovEntityFactory.eINSTANCE.createAction();
            tempAction.setAction(each);
            Optional<Transition<Double>> result = markovModelAccessor.findTransition(source, tempAction);
            Transition<Double> value = result.orElseThrow(() -> new RuntimeException(""));
            results.add(value);
        }
        return results;
    }

    private Double selectRandomly(Set<Double> options) {
        return new RandomizedStrategy<Double>().select(null, options);
    }

}
