package org.palladiosimulator.simexp.markovian.exploitation;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

import org.palladiosimulator.simexp.markovian.access.MarkovModelAccessor;
import org.palladiosimulator.simexp.markovian.activity.Policy;
import org.palladiosimulator.simexp.markovian.exploration.RandomizedStrategy;
import org.palladiosimulator.simexp.markovian.model.markovmodel.markoventity.Action;
import org.palladiosimulator.simexp.markovian.model.markovmodel.markoventity.MarkovModel;
import org.palladiosimulator.simexp.markovian.model.markovmodel.markoventity.State;
import org.palladiosimulator.simexp.markovian.model.markovmodel.markoventity.Transition;

public class ProbabilityBasedActionPolicy<S, R> implements Policy<S, Double, Action<Double>> {

    private final static String POLICY_NAME = "ProbabilityBasedActionSelection";

    private final Optional<MarkovModelAccessor<S, Double, R>> markovAccessor;

    public ProbabilityBasedActionPolicy(Optional<MarkovModel<S, Double, R>> markovModel) {
        if (markovModel.isPresent()) {
            MarkovModel<S, Double, R> model = markovModel.get();
            MarkovModelAccessor<S, Double, R> accessor = MarkovModelAccessor.of(model);
            this.markovAccessor = Optional.of(accessor);
        } else {
            this.markovAccessor = Optional.empty();
        }
    }

    @Override
    public String getId() {
        return POLICY_NAME;
    }

    @Override
    public Action<Double> select(State<S> source, Set<Action<Double>> options) {
        if (markovAccessor.isPresent()) {
            return selectAccordingToModel(source, options);
        }
        return selectRandomly(options);
    }

    private Action<Double> selectAccordingToModel(State<S> source, Set<Action<Double>> options) {
        ProbabilityBasedTransitionPolicy<S, Double> probabilityBasedTransitionPolicy = new ProbabilityBasedTransitionPolicy<>();
        Set<Transition<S, Double>> filterTransitions = filterTransitions(source, options);
        Transition<S, Double> s = probabilityBasedTransitionPolicy.select(null, filterTransitions);
        Action<Double> label = s.getLabel();
        return label;
    }

    private Set<Transition<S, Double>> filterTransitions(State<S> source, Set<Action<Double>> options) {
        Set<Transition<S, Double>> results = new HashSet<>();
        for (Action<Double> each : options) {
            // TODO exception handling
            MarkovModelAccessor<S, Double, R> markovModelAccessor = markovAccessor.get();
            Optional<Transition<S, Double>> transition = markovModelAccessor.findTransition(source, each);
            Transition<S, Double> result = transition.orElseThrow(() -> new RuntimeException(""));
            results.add(result);
        }
        return results;
    }

    private Action<Double> selectRandomly(Set<Action<Double>> options) {
        return new RandomizedStrategy<S, Action<Double>>().select(null, options);
    }

}
