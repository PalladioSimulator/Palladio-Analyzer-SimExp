/* generated by Xtext 2.26.0
 */
package org.palladiosimulator.simexp.dsl.kmodel.validation;

import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.ValidationMessageAcceptor;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Action;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.ActionCall;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.ArgumentKeyValue;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Array;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Bounds;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Constant;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.DataType;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.EnvVariable;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Expression;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Field;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.IfStatement;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Kmodel;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.KmodelPackage;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Literal;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Operation;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Parameter;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Probe;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Range;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Variable;
import org.palladiosimulator.simexp.dsl.kmodel.util.KmodelDataTypeSwitch;

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class KmodelValidator extends AbstractKmodelValidator {

    private final KmodelDataTypeSwitch typeSwitch;

    public KmodelValidator() {
        super();
        this.typeSwitch = new KmodelDataTypeSwitch();
    }

    @Check
    public void checkKmodel(Kmodel model) {
        String modelName = model.getModelName();
        if (modelName == null) {
            warning("No modelName given.", model, KmodelPackage.Literals.KMODEL__MODEL_NAME);
        } else {
            if (modelName.isEmpty()) {
                warning("Empty modelName.", model, KmodelPackage.Literals.KMODEL__MODEL_NAME);
            }
        }

        checkDuplicateIds("probe", model.getProbes(), Comparator.comparing(Probe::getKind)
            .thenComparing(Probe::getIdentifier));
        checkDuplicateIds("envvar", model.getEnvVariables(), Comparator.comparing(EnvVariable::getStaticId)
            .thenComparing(EnvVariable::getDynamicId));

        checkUnusedFields(model.getConstants());
        checkUnusedFields(model.getVariables());
        checkUnusedFields(model.getEnvVariables());
        checkUnusedFields(model.getProbes());
        checkUnusedFields(model.getRuntimes());

        List<Action> actions = model.getActions();
        for (int i = 0; i < actions.size(); i++) {
            Action action = actions.get(i);
            Collection<EStructuralFeature.Setting> actionReferences = EcoreUtil.UsageCrossReferencer.find(action,
                    action.eResource());

            if (actionReferences.isEmpty()) {
                warning("The action '" + action.getName() + "' is never used.", KmodelPackage.Literals.KMODEL__ACTIONS,
                        i);
            }
        }
    }

    private void checkUnusedFields(List<? extends Field> fields) {
        ListIterator<? extends Field> iter = fields.listIterator();
        while (iter.hasNext()) {
            int index = iter.nextIndex();
            Field field = iter.next();
            Resource resource = field.eResource();
            Collection<EStructuralFeature.Setting> fieldReferences = EcoreUtil.UsageCrossReferencer.find(field,
                    resource);

            if (fieldReferences.isEmpty()) {
                EStructuralFeature feature = field.eContainmentFeature();
                warning(String.format("The field '%s' is never used.", field.getName()), feature, index);
            }
        }
    }

    private <T extends Field> void checkDuplicateIds(String type, List<T> fields, Comparator<T> comparator) {
        Set<T> duplicates = findDuplicates(fields, comparator);
        for (T duplicate : duplicates) {
            EStructuralFeature feature = duplicate.eContainmentFeature();
            error(String.format("%s '%s' duplicate addressing.", type, duplicate.getName()), feature);
        }
    }

    private <T> Set<T> findDuplicates(List<T> fields, Comparator<T> comparator) {
        Set<T> items = new TreeSet<>(comparator);
        return fields.stream()
            .filter(n -> !items.add(n))
            .collect(Collectors.toSet());
    }

    @Check
    public void checkConstant(Constant constant) {
        Set<Field> allFieldReferences = getAllFieldReferences(constant);

        if (containsNonConstantFieldReference(allFieldReferences)) {
            error("Cannot assign an expression containing a non-constant value to a constant.",
                    KmodelPackage.Literals.CONSTANT__VALUE);
            return;
        }
        if (containsCyclicReferences(constant, allFieldReferences)) {
            error("Cyclic reference detected.", constant, KmodelPackage.Literals.CONSTANT__VALUE);
        }

        if (allFieldReferences.size() == 1) {
            warning("Constant '" + constant.getName() + "' is probably redundant.",
                    KmodelPackage.Literals.CONSTANT__VALUE);
        }

        Expression expression = constant.getValue();
        if (expression != null) {
            DataType constantDataType = getDataType(constant);
            DataType valueDataType = getDataType(expression);
            if (!checkTypes(constantDataType, valueDataType, KmodelPackage.Literals.CONSTANT__VALUE)) {
                return;
            }
        }
    }

    private boolean containsCyclicReferences(Constant constant, Set<Field> allFieldReferences) {
        for (Field field : allFieldReferences) {
            Constant referredConstant = (Constant) field;
            Set<Field> others = getAllFieldReferences(referredConstant);
            if (others.contains(constant)) {
                return true;
            }
        }
        return false;
    }

    private Set<Field> getAllFieldReferences(Constant constant) {
        Expression expression = constant.getValue();
        return getAllFieldReferences(expression);
    }

    private Set<Field> getAllFieldReferences(Expression expression) {
        if (expression == null) {
            return Collections.emptySet();
        }

        Set<Field> fieldReferences = new HashSet<>();
        Field field = expression.getFieldRef();
        if (field != null) {
            fieldReferences.add(field);
        }

        Expression left = expression.getLeft();
        Expression right = expression.getRight();

        Set<Field> leftFieldReferences = getAllFieldReferences(left);
        Set<Field> rightFieldReferences = getAllFieldReferences(right);

        fieldReferences.addAll(leftFieldReferences);
        fieldReferences.addAll(rightFieldReferences);

        return fieldReferences;
    }

    @Check
    public void checkVariable(Variable variable) {
        DataType dataType = getDataType(variable);
        Bounds bounds = variable.getValues();

        if (bounds != null) {
            if (!compatibleTypes(DataType.FLOAT, dataType) && bounds instanceof Range) {
                error("Cannot assign a range to a variable of the type '" + dataType + "'.",
                        KmodelPackage.Literals.VARIABLE__VALUES);
            }
        }
    }

    @Check
    public void checkArray(Array array) {
        DataType dataType = getDataType(array);
        List<Literal> values = array.getValues();

        for (int i = 0; i < values.size(); i++) {
            DataType valueType = getDataType(values.get(i));
            checkTypes(dataType, valueType, KmodelPackage.Literals.ARRAY__VALUES, i);
        }
    }

    @Check
    public void checkRange(Range range) {
        DataType dataType = getDataType(range);
        Literal startValue = range.getStartValue();
        Literal endValue = range.getEndValue();
        Literal stepSize = range.getStepSize();

        if (startValue != null) {
            DataType startValueType = getDataType(startValue);
            checkTypes(dataType, startValueType, KmodelPackage.Literals.RANGE__START_VALUE);
        }

        if (endValue != null) {
            DataType endValueType = getDataType(endValue);
            checkTypes(dataType, endValueType, KmodelPackage.Literals.RANGE__END_VALUE);
        }

        if (stepSize != null) {
            DataType stepSizeType = getDataType(stepSize);
            checkTypes(dataType, stepSizeType, KmodelPackage.Literals.RANGE__STEP_SIZE);
        }
    }

    @Check
    public void checkIfStatement(IfStatement ifStatement) {
        Expression condition = ifStatement.getCondition();

        if (condition != null) {
            DataType conditionType = getDataType(condition);
            checkTypes(DataType.BOOL, conditionType, KmodelPackage.Literals.IF_STATEMENT__CONDITION);
        }
    }

    @Check
    public void checkActionCall(ActionCall actionCall) {
        Action action = actionCall.getActionRef();

        if (action != null) {
            List<ArgumentKeyValue> arguments = actionCall.getArguments();
            List<Parameter> parameters = action.getParameterList()
                .getParameters();

            if (arguments.size() != parameters.size()) {
                error("Expected " + parameters.size() + " arguments, got " + arguments.size() + " instead.",
                        KmodelPackage.Literals.ACTION_CALL__ARGUMENTS);
                return;
            }

            for (int i = 0; i < arguments.size(); i++) {
                Field parameter = parameters.get(i);
                ArgumentKeyValue argument = arguments.get(i);

                if (!argument.getParamRef()
                    .equals(parameter)) {
                    error("Arguments must be provided in the order as declared.",
                            KmodelPackage.Literals.ACTION_CALL__ARGUMENTS, i);
                    return;
                }

                DataType parameterType = getDataType(parameter);
                DataType argumentType = getDataType(argument);
                checkTypes(parameterType, argumentType, KmodelPackage.Literals.ACTION_CALL__ARGUMENTS, i);
            }
        }
    }

    @Check
    public void checkExpression(Expression expression) {
        Operation operation = expression.getOp();

        DataType leftType = null;
        if (expression.getLeft() != null) {
            leftType = getDataType(expression.getLeft());
        }

        DataType rightType = null;
        if (expression.getRight() != null) {
            rightType = getDataType(expression.getRight());
        }

        switch (operation) {
        case UNDEFINED:
            break;

        case OR:
        case AND:
        case NOT:
            checkTypes(DataType.BOOL, leftType, KmodelPackage.Literals.EXPRESSION__LEFT);
            if (rightType != null) {
                checkTypes(DataType.BOOL, rightType, KmodelPackage.Literals.EXPRESSION__RIGHT);
            }
            break;

        case EQUAL:
        case UNEQUAL:
            if (leftType == DataType.FLOAT || rightType == DataType.FLOAT) {
                checkTypes(DataType.FLOAT, leftType, KmodelPackage.Literals.EXPRESSION__LEFT);
                checkTypes(DataType.FLOAT, rightType, KmodelPackage.Literals.EXPRESSION__RIGHT);
            } else {
                checkTypes(rightType, leftType, KmodelPackage.Literals.EXPRESSION__LEFT);
                checkTypes(leftType, rightType, KmodelPackage.Literals.EXPRESSION__RIGHT);
            }
            break;

        case SMALLER:
        case SMALLER_OR_EQUAL:
        case GREATER_OR_EQUAL:
        case GREATER:
        case PLUS:
        case MINUS:
        case MULTIPLY:
        case DIVIDE:
        case MODULO:
            checkTypes(DataType.FLOAT, leftType, KmodelPackage.Literals.EXPRESSION__LEFT);
            if (rightType != null) {
                checkTypes(DataType.FLOAT, rightType, KmodelPackage.Literals.EXPRESSION__RIGHT);
            }
            break;

        default:
            throw new RuntimeException("Cannot validate expression with operation '" + operation + "'.");
        }
    }

    private DataType getDataType(EObject object) {
        return typeSwitch.doSwitch(object);
    }

    private boolean checkTypes(DataType expected, DataType actual, EStructuralFeature feature) {
        return checkTypes(expected, actual, feature, ValidationMessageAcceptor.INSIGNIFICANT_INDEX);
    }

    private boolean checkTypes(DataType expected, DataType actual, EStructuralFeature feature, int index) {
        /*
         * The type UNDEFINED can only occur as a default value in unresolved field references, or
         * when an expression isn't complete. In this cases, no error message regarding the type
         * should be shown.
         */
        if (actual == DataType.UNDEFINED) {
            return false;
        }

        if (!compatibleTypes(expected, actual)) {
            StringBuilder errorMessage = new StringBuilder("Expected a value of type '");

            if (expected == DataType.FLOAT) {
                errorMessage.append(DataType.INT + "' or '" + DataType.FLOAT);
            } else {
                errorMessage.append(expected);
            }

            errorMessage.append("', got '" + actual + "' instead.");

            error(errorMessage.toString(), feature, index);

            return false;
        }

        return true;
    }

    private boolean compatibleTypes(DataType expected, DataType actual) {
        return expected == actual || isSubtypeOf(expected, actual);
    }

    private boolean isSubtypeOf(DataType supertype, DataType subtype) {
        return supertype == DataType.FLOAT && subtype == DataType.INT;
    }

    private boolean containsNonConstantFieldReference(Set<Field> fields) {
        for (Field field : fields) {
            if (!(field instanceof Constant)) {
                return true;
            }
        }
        return false;
    }
}
