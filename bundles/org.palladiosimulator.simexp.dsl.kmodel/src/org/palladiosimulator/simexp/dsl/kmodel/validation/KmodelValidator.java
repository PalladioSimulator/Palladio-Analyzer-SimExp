/* generated by Xtext 2.26.0
 */
package org.palladiosimulator.simexp.dsl.kmodel.validation;

import java.util.Collection;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.ValidationMessageAcceptor;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Action;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.ActionCall;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.ArgumentKeyValue;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Array;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Bounds;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Constant;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.DataType;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Expression;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Field;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.IfStatement;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Kmodel;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.KmodelPackage;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Literal;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.ModelName;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Operation;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Probe;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Range;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Variable;

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class KmodelValidator extends AbstractKmodelValidator {

    private final KmodelDataTypeSwitch typeSwitch;

    public KmodelValidator() {
        super();
        this.typeSwitch = new KmodelDataTypeSwitch();
    }

    @Check
    public void checkKmodel(Kmodel model) {
        ModelName modelName = model.getModelName();
        if (modelName == null) {
            warning("No modelName given.", model, KmodelPackage.Literals.KMODEL__MODEL_NAME);
        } else {
            if (modelName.getName()
                .isEmpty()) {
                warning("Empty modelName.", modelName, KmodelPackage.Literals.MODEL_NAME__NAME);
            }
        }

        List<Field> fields = model.getFields();
        for (int i = 0; i < fields.size(); i++) {
            Field field = fields.get(i);
            Collection<EStructuralFeature.Setting> fieldReferences = EcoreUtil.UsageCrossReferencer.find(field,
                    field.eResource());

            if (fieldReferences.isEmpty()) {
                warning("The field '" + field.getName() + "' is never used.", KmodelPackage.Literals.KMODEL__FIELDS, i);
            }
        }

        List<Action> actions = model.getActions();
        for (int i = 0; i < actions.size(); i++) {
            Action action = actions.get(i);
            Collection<EStructuralFeature.Setting> actionReferences = EcoreUtil.UsageCrossReferencer.find(action,
                    action.eResource());

            if (actionReferences.isEmpty()) {
                warning("The action '" + action.getName() + "' is never used.", KmodelPackage.Literals.KMODEL__ACTIONS,
                        i);
            }
        }
    }

    @Check
    public void checkConstant(Constant constant) {
        Expression value = constant.getValue();

        if (value != null) {
            if (containsNonConstantFieldReference(value)) {
                error("Cannot assign an expression containing a non-constant value to a constant.",
                        KmodelPackage.Literals.CONSTANT__VALUE);
                return;
            }

            DataType constantDataType = getDataType(constant);
            DataType valueDataType = getDataType(value);
            if (!checkTypes(constantDataType, valueDataType, KmodelPackage.Literals.CONSTANT__VALUE)) {
                return;
            }

            if (containsOnlySingleConstant(value)) {
                warning("Constant '" + constant.getName() + "' is probably redundant.",
                        KmodelPackage.Literals.CONSTANT__VALUE);
            }
        }
    }

    @Check
    public void checkVariable(Variable variable) {
        DataType dataType = getDataType(variable);
        Bounds bounds = variable.getValues();

        if (bounds != null) {
            if (!compatibleTypes(DataType.FLOAT, dataType) && bounds instanceof Range) {
                error("Cannot assign a range to a variable of the type '" + dataType + "'.",
                        KmodelPackage.Literals.VARIABLE__VALUES);
            }
        }
    }

    @Check
    public void checkArray(Array array) {
        DataType dataType = getDataType(array);
        List<Literal> values = array.getValues();

        for (int i = 0; i < values.size(); i++) {
            DataType valueType = getDataType(values.get(i));
            checkTypes(dataType, valueType, KmodelPackage.Literals.ARRAY__VALUES, i);
        }
    }

    @Check
    public void checkRange(Range range) {
        DataType dataType = getDataType(range);
        Literal startValue = range.getStartValue();
        Literal endValue = range.getEndValue();
        Literal stepSize = range.getStepSize();

        if (startValue != null) {
            DataType startValueType = getDataType(startValue);
            checkTypes(dataType, startValueType, KmodelPackage.Literals.RANGE__START_VALUE);
        }

        if (endValue != null) {
            DataType endValueType = getDataType(endValue);
            checkTypes(dataType, endValueType, KmodelPackage.Literals.RANGE__END_VALUE);
        }

        if (stepSize != null) {
            DataType stepSizeType = getDataType(stepSize);
            checkTypes(dataType, stepSizeType, KmodelPackage.Literals.RANGE__STEP_SIZE);
        }
    }

    @Check
    public void checkProbe(Probe probe) {
        EObject root = EcoreUtil2.getRootContainer(probe);
        List<Probe> probes = EcoreUtil2.getAllContentsOfType(root, Probe.class);
        probes.remove(probe);

        for (int i = 0; i < probes.size(); i++) {
            Probe otherProbe = probes.get(i);
            if (probe.getId()
                .equals(otherProbe.getId())) {
                warning("Probes '" + probe.getName() + "' and '" + otherProbe.getName() + "' are probably redundant.",
                        KmodelPackage.Literals.PROBE__ID);
            }
        }
    }

    @Check
    public void checkIfStatement(IfStatement ifStatement) {
        Expression condition = ifStatement.getCondition();

        if (condition != null) {
            DataType conditionType = getDataType(condition);
            checkTypes(DataType.BOOL, conditionType, KmodelPackage.Literals.IF_STATEMENT__CONDITION);
        }
    }

    @Check
    public void checkActionCall(ActionCall actionCall) {
        Action action = actionCall.getActionRef();

        if (action != null) {
            List<ArgumentKeyValue> arguments = actionCall.getArguments();
            List<Field> parameters = action.getParameterList()
                .getParameters();

            if (arguments.size() != parameters.size()) {
                error("Expected " + parameters.size() + " arguments, got " + arguments.size() + " instead.",
                        KmodelPackage.Literals.ACTION_CALL__ARGUMENTS);
                return;
            }

            for (int i = 0; i < arguments.size(); i++) {
                Field parameter = parameters.get(i);
                ArgumentKeyValue argument = arguments.get(i);

                if (!argument.getParamRef()
                    .equals(parameter)) {
                    error("Arguments must be provided in the order as declared.",
                            KmodelPackage.Literals.ACTION_CALL__ARGUMENTS, i);
                    return;
                }

                DataType parameterType = getDataType(parameter);
                DataType argumentType = getDataType(argument);
                checkTypes(parameterType, argumentType, KmodelPackage.Literals.ACTION_CALL__ARGUMENTS, i);
            }
        }
    }

    @Check
    public void checkExpression(Expression expression) {
        Operation operation = expression.getOp();

        DataType leftType = null;
        if (expression.getLeft() != null) {
            leftType = getDataType(expression.getLeft());
        }

        DataType rightType = null;
        if (expression.getRight() != null) {
            rightType = getDataType(expression.getRight());
        }

        switch (operation) {
        case UNDEFINED:
            break;

        case OR:
        case AND:
        case NOT:
            checkTypes(DataType.BOOL, leftType, KmodelPackage.Literals.EXPRESSION__LEFT);
            if (rightType != null) {
                checkTypes(DataType.BOOL, rightType, KmodelPackage.Literals.EXPRESSION__RIGHT);
            }
            break;

        case EQUAL:
        case UNEQUAL:
            if (leftType == DataType.FLOAT || rightType == DataType.FLOAT) {
                checkTypes(DataType.FLOAT, leftType, KmodelPackage.Literals.EXPRESSION__LEFT);
                checkTypes(DataType.FLOAT, rightType, KmodelPackage.Literals.EXPRESSION__RIGHT);
            } else {
                checkTypes(rightType, leftType, KmodelPackage.Literals.EXPRESSION__LEFT);
                checkTypes(leftType, rightType, KmodelPackage.Literals.EXPRESSION__RIGHT);
            }
            break;

        case SMALLER:
        case SMALLER_OR_EQUAL:
        case GREATER_OR_EQUAL:
        case GREATER:
        case PLUS:
        case MINUS:
        case MULTIPLY:
        case DIVIDE:
        case MODULO:
            checkTypes(DataType.FLOAT, leftType, KmodelPackage.Literals.EXPRESSION__LEFT);
            if (rightType != null) {
                checkTypes(DataType.FLOAT, rightType, KmodelPackage.Literals.EXPRESSION__RIGHT);
            }
            break;

        default:
            throw new RuntimeException("Cannot validate expression with operation '" + operation + "'.");
        }
    }

    // Returns the next expression in the tree that contains either an operation, a field reference
    // or a literal.
    public Expression getNextExpressionWithContent(Expression expression) {
        if (expression.getOp() != Operation.UNDEFINED || expression.getFieldRef() != null
                || expression.getLiteral() != null) {
            return expression;

        } else {
            return getNextExpressionWithContent(expression.getLeft());
        }
    }

    public DataType getDataType(EObject object) {
        return typeSwitch.doSwitch(object);
    }

    private boolean checkTypes(DataType expected, DataType actual, EStructuralFeature feature) {
        return checkTypes(expected, actual, feature, ValidationMessageAcceptor.INSIGNIFICANT_INDEX);
    }

    private boolean checkTypes(DataType expected, DataType actual, EStructuralFeature feature, int index) {
        /*
         * The type UNDEFINED can only occur as a default value in unresolved field references, or
         * when an expression isn't complete. In this cases, no error message regarding the type
         * should be shown.
         */
        if (actual == DataType.UNDEFINED) {
            return false;
        }

        if (!compatibleTypes(expected, actual)) {
            StringBuilder errorMessage = new StringBuilder("Expected a value of type '");

            if (expected == DataType.FLOAT) {
                errorMessage.append(DataType.INT + "' or '" + DataType.FLOAT);
            } else {
                errorMessage.append(expected);
            }

            errorMessage.append("', got '" + actual + "' instead.");

            error(errorMessage.toString(), feature, index);

            return false;
        }

        return true;
    }

    private boolean compatibleTypes(DataType expected, DataType actual) {
        return expected == actual || isSubtypeOf(expected, actual);
    }

    private boolean isSubtypeOf(DataType supertype, DataType subtype) {
        return supertype == DataType.FLOAT && subtype == DataType.INT;
    }

    private boolean containsNonConstantFieldReference(Expression expression) {
        if (expression == null) {
            return false;
        }

        Expression left = expression.getLeft();
        Expression right = expression.getRight();

        if (left != null) {
            if (right != null) {
                return containsNonConstantFieldReference(left) || containsNonConstantFieldReference(right);
            }

            return containsNonConstantFieldReference(left);
        }

        Field field = expression.getFieldRef();
        return field != null && field.getDataType() != DataType.UNDEFINED && !(field instanceof Constant);
    }

    private boolean containsOnlySingleConstant(Expression expression) {
        if (expression == null) {
            return false;
        }

        Expression next = getNextExpressionWithContent(expression);
        Field fieldRef = next.getFieldRef();

        return fieldRef != null;
    }
}
