grammar org.palladiosimulator.simexp.dsl.kmodel.Kmodel with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate kmodel "http://www.palladiosimulator.org/simexp/dsl/kmodel/Kmodel"

Kmodel:
	'modelName' '=' modelName=STRING ';'
	(constants+=Constant |
	variables+=Variable  ';' |
	probes+=Probe |
	runtimes+=Runtime)*
	(actions+=Action)*
	(statements+=IfStatement)*
	;
	
Field:
	(Constant | Variable | Probe | Runtime | Parameter)
	;

Constant:
	{Constant} 'const' dataType=PrimitiveType name=ID '=' value=DisjunctiveExpr ';'
	;

Variable:
	{Variable} 'var' dataType=PrimitiveType values=Bounds name=ID
	;

Probe:
	{Probe} 'probe' dataType=PrimitiveType name=ID ':' kind=ProbeAdressingKind identifier=STRING ';'
	;

enum ProbeAdressingKind:
    MONITORID='monitorId' | ID='id';

Runtime:
	{Runtime} 'runtime' dataType=PrimitiveType name=ID ':' 'simple' ':' exp=EcoreExpression ';';

Parameter:
	{Parameter} 'param' dataType=PrimitiveType name=ID;

Bounds:
	{Array} '{' (values+=Literal (',' values+=Literal)*) '}' |
	{Range} '[' startValue=Literal ',' endValue=Literal ',' stepSize=Literal ']';

EcoreExpression: name=ID ((withIndex?='[' index=INT ']') | 
	(withPredicate?='{' param=ID '=' value=Literal '}'))? ('.' exp=EcoreExpression)?;
	
Action: 'action' name=ID '(' parameterList=ParameterList ')' ';';

ParameterList: {ParameterList}
	(((parameters+=Parameter (',' parameters+=Parameter)* (',' variables+=Variable)*)) |
	(variables+=Variable (',' variables+=Variable)*))?;

Statement:
	ActionCall | IfStatement;

ActionCall returns Statement:
	{ActionCall} actionRef=[Action] '(' (arguments+=ArgumentKeyValue (',' arguments+=ArgumentKeyValue)*)? ')' ';';

ArgumentKeyValue:
	paramRef=[Parameter] '=' argument=DisjunctiveExpr;

IfStatement returns Statement: {IfStatement}
	'if' '(' condition=DisjunctiveExpr ')' '{' (thenStatements+=Statement)* '}'
	(withElse?='else' '{' (elseStatements+=Statement)* '}')?;

DisjunctiveExpr returns Expression:
    ConjunctiveExpr ({Expression.left=current} op=DisjunctiveOp right=ConjunctiveExpr)*;

ConjunctiveExpr returns Expression:
	EquativeExpr ({Expression.left=current} op=ConjunctiveOp right=EquativeExpr)*;

EquativeExpr returns Expression:
	RelationalExpr ({Expression.left=current} op=EquativeOp right=RelationalExpr)*;

RelationalExpr returns Expression:
	AdditiveExpr ({Expression.left=current} op=RelativeOp right=AdditiveExpr)?;

AdditiveExpr returns Expression:
	MultiplicativeExpr ({Expression.left=current} op=AdditiveOp right=MultiplicativeExpr)*;

MultiplicativeExpr returns Expression:
	UnaryExpr ({Expression.left=current} op=MultiplicativeOp right=UnaryExpr)*;

UnaryExpr returns Expression:
	{Expression} op=UnaryOp? left=Term;

Term returns Expression:
	{Expression} (fieldRef=[Field] | literal=Literal | '(' left=DisjunctiveExpr ')');

Literal:
	{BoolLiteral} true=BOOL |
	{IntLiteral} value=INT |
	{FloatLiteral} value=FLOAT |
	{StringLiteral} value=STRING;

// Rule 'DataType' is not used, but is necessary to provide a default value for data types.
enum DataType: UNDEFINED;
enum PrimitiveType returns DataType: BOOL = 'bool' | INT = 'int' | FLOAT = 'float' | STRING = 'string';

// Rule 'Operation' is not used, but is necessary to provide a default value for operations.
enum Operation: UNDEFINED;
enum DisjunctiveOp returns Operation: OR = '||';
enum ConjunctiveOp returns Operation: AND = '&&';
enum EquativeOp returns Operation: EQUAL = '==' | UNEQUAL = '!=';
enum RelativeOp returns Operation: SMALLER = '<' | SMALLER_OR_EQUAL = '<=' | GREATER_OR_EQUAL = '>=' | GREATER = '>';
enum AdditiveOp returns Operation: PLUS = '+' | MINUS = '-';
enum MultiplicativeOp returns Operation: MULTIPLY = '*' | DIVIDE = '/' | MODULO = '%';
enum UnaryOp returns Operation: PLUS = '+' | MINUS = '-' | NOT = '!';

terminal BOOL returns ecore::EBoolean: 'true' | 'false';
terminal FLOAT returns ecore::EFloat: ((INT)? '.' INT (('e' | 'E') ('-')? INT)?) | (INT ('e' | 'E') ('-')? INT);