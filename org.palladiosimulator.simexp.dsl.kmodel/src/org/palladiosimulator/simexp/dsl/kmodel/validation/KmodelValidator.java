/*
 * generated by Xtext 2.26.0
 */
package org.palladiosimulator.simexp.dsl.kmodel.validation;

import org.eclipse.xtext.validation.Check;
import java.util.Collections;
import java.util.List;
import java.util.NoSuchElementException;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Action;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Addition;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.AdditiveInversion;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.BoolLiteral;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Comparison;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Conjunction;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Constant;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.DataType;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Disjunction;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Equality;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Expression;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Field;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.FloatLiteral;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.IntLiteral;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.KModel;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.KmodelPackage;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Multiplication;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Negation;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Statement;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.StringLiteral;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Variable;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class KmodelValidator extends AbstractKmodelValidator {
	
	@Check
	public void checkFieldReferenceDefinedBefore(Expression expression) {
		Field field = expression.getFieldRef();
		
		if (field != null && !fieldsDefinedBefore(expression).contains(field)) {
			String name = field.getName();
			if (name != null) {
				error("Field '" + name + "' must be defined before referencing.",
						KmodelPackage.Literals.EXPRESSION__FIELD_REF);
			}
		}
	}
	
	@Check
	public void checkConstantForVariableValue(Constant constant) {
		Expression value = constant.getValue();
		
		if (containsVariable(value)) {
			error("Cannot assign an expression containing a variable to a constant value.",
					KmodelPackage.Literals.CONSTANT__VALUE);
		}
	}
	
	@Check
	public void checkConstantValueDataType(Constant constant) {
		Expression value = constant.getValue();
		
		if (value != null) {
			DataType constantDataType = constant.getDataType();
			DataType valueDataType = getDataType(value);
			
			if (!constantDataType.equals(valueDataType)) {
				error("Expected a value of type '"
						+ constantDataType + "'. Got '" + valueDataType + "' instead.",
						KmodelPackage.Literals.CONSTANT__VALUE);
			}
		}
	}
	
	@Check
	public void checkConditionDataType(Statement statement) {
		Expression condition = statement.getCondition();
		
		if (condition != null) {
			DataType conditionType = getDataType(condition);
			
			if (!conditionType.equals(DataType.BOOL)) {
				error("The condition must be of type '" + DataType.BOOL 
						+ "'. Got '" + conditionType + "' instead.",
						KmodelPackage.Literals.STATEMENT__CONDITION);
			}
		}
	}
	
	@Check
	public void checkArgumentDataType(Statement statement) {
		Action action = statement.getActionRef();
		Expression argument = statement.getArgument();
		
		if (action != null && argument != null) {
			DataType parameterType = action.getParameter().getDataType();
			DataType argumentType = getDataType(argument);
			
			if (!parameterType.equals(argumentType)) {
				error("Expected an argument of type '"
						+ parameterType + "'. Got '" + argumentType + "' instead.",
						KmodelPackage.Literals.STATEMENT__ARGUMENT);
			}
		}
	}
	
	@Check
	public void checkDisjunctionExpression(Disjunction disjunction) {
		DataType leftDataType = getDataType(disjunction.getLeft());
		DataType rightDataType = getDataType(disjunction.getRight());
		
		if (leftDataType != DataType.BOOL) {
			error("Expected a value of type '" + DataType.BOOL + "'. Got '" + leftDataType + "' instead.", 
					KmodelPackage.Literals.DISJUNCTION__LEFT);
		}
		
		if (rightDataType != DataType.BOOL) {
			error("Expected a value of type '" + DataType.BOOL + "'. Got '" + rightDataType + "' instead.", 
					KmodelPackage.Literals.DISJUNCTION__RIGHT);
		}
	}
	
	@Check
	public void checkConjunctionExpression(Conjunction conjunction) {
		DataType leftDataType = getDataType(conjunction.getLeft());
		DataType rightDataType = getDataType(conjunction.getRight());
		
		if (leftDataType != DataType.BOOL) {
			error("Expected a value of type '" + DataType.BOOL + "'. Got '" + leftDataType + "' instead.", 
					KmodelPackage.Literals.CONJUNCTION__LEFT);
		}
		
		if (rightDataType != DataType.BOOL) {
			error("Expected a value of type '" + DataType.BOOL + "'. Got '" + rightDataType + "' instead.", 
					KmodelPackage.Literals.CONJUNCTION__RIGHT);
		}
	}
	
	@Check
	public void checkEqualityExpression(Equality equality) {
		DataType leftDataType = getDataType(equality.getLeft());
		DataType rightDataType = getDataType(equality.getRight());
		
		boolean leftIsNumber = leftDataType == DataType.INT || leftDataType == DataType.FLOAT;
		boolean rightIsNumber = rightDataType == DataType.INT || rightDataType == DataType.FLOAT;
		
		if (!(leftIsNumber && rightIsNumber) && leftDataType != rightDataType) {
			error("Cannot compare the equality of a '"
					+ leftDataType + "' value with a '" + rightDataType + "' value.",
					KmodelPackage.Literals.EQUALITY__LEFT);
			
			error("Cannot compare the equality of a '"
					+ leftDataType + "' value with a '" + rightDataType + "' value.",
					KmodelPackage.Literals.EQUALITY__RIGHT);
		}
	}
	
	@Check
	public void checkNegationExpression(Negation negation) {
		if (negation.isNegated()) {
			DataType type = getDataType(negation.getExpr());
			
			if (type != DataType.BOOL) {
				error("Cannot negate a '" + type + "' value.",
						KmodelPackage.Literals.EXPRESSION__EXPR);
			}
		}
	}
	
	@Check
	public void checkComparisonExpression(Comparison comparison) {
		DataType leftDataType = getDataType(comparison.getLeft());
		DataType rightDataType = getDataType(comparison.getRight());
		
		boolean leftIsNumber = leftDataType == DataType.INT || leftDataType == DataType.FLOAT;
		boolean rightIsNumber = rightDataType == DataType.INT || rightDataType == DataType.FLOAT;
		
		if (!leftIsNumber) {
			error("Cannot compare a '"
					+ leftDataType + "' value with a '" + rightDataType + "' value.",
					KmodelPackage.Literals.COMPARISON__LEFT);
		}
		
		if (!rightIsNumber) {
			error("Cannot compare a '"
					+ leftDataType + "' value with a '" + rightDataType + "' value.",
					KmodelPackage.Literals.COMPARISON__RIGHT);
		}
	}
	
	@Check
	public void checkAdditionExpression(Addition addition) {
		DataType leftDataType = getDataType(addition.getLeft());
		DataType rightDataType = getDataType(addition.getRight());
		
		boolean leftIsNumber = leftDataType == DataType.INT || leftDataType == DataType.FLOAT;
		boolean rightIsNumber = rightDataType == DataType.INT || rightDataType == DataType.FLOAT;
		
		if (!leftIsNumber) {
			error("Cannot add or subtract a '"
					+ leftDataType + "' value with a '" + rightDataType + "' value.",
					KmodelPackage.Literals.ADDITION__LEFT);
		}
		
		if (!rightIsNumber) {
			error("Cannot add or subtract a '"
					+ leftDataType + "' value with a '" + rightDataType + "' value.",
					KmodelPackage.Literals.ADDITION__RIGHT);
		}
	}
	
	@Check
	public void checkAdditiveInversionExpression(AdditiveInversion inversion) {
		if (inversion.isInverted()) {
			DataType type = getDataType(inversion);
			
			if (type != DataType.INT && type != DataType.FLOAT) {
				error("Cannot invert a '" + type + "' value.",
						KmodelPackage.Literals.EXPRESSION__EXPR);
			}
		}
	}
	
	@Check
	public void checkMultiplicationExpression(Multiplication multiplication) {
		DataType leftDataType = getDataType(multiplication.getLeft());
		DataType rightDataType = getDataType(multiplication.getRight());
		
		boolean leftIsNumber = leftDataType == DataType.INT || leftDataType == DataType.FLOAT;
		boolean rightIsNumber = rightDataType == DataType.INT || rightDataType == DataType.FLOAT;
		
		if (!leftIsNumber) {
			error("Cannot multiply or divide a '"
					+ leftDataType + "' value with a '" + rightDataType + "' value.",
					KmodelPackage.Literals.MULTIPLICATION__LEFT);
		}
		
		if (!rightIsNumber) {
			error("Cannot multiply or divide a '"
					+ leftDataType + "' value with a '" + rightDataType + "' value.",
					KmodelPackage.Literals.MULTIPLICATION__RIGHT);
		}
	}
	
	private DataType getDataType(Expression expression) {
		if (expression instanceof Disjunction) {
			Disjunction disjunction = (Disjunction) expression;
			
			if (disjunction.getRight() != null) {
				return DataType.BOOL;
			} else {
				return getDataType(disjunction.getLeft());
			}
		}
		
		if (expression instanceof Conjunction) {
			Conjunction conjunction = (Conjunction) expression;
			
			if (conjunction.getRight() != null) {
				return DataType.BOOL;
			} else {
				return getDataType(conjunction.getLeft());
			}
		}
		
		if (expression instanceof Equality) {
			Equality equality = (Equality) expression;
			
			if (equality.getRight() != null) {
				return DataType.BOOL;
			} else {
				return getDataType(equality.getLeft());
			}
		}
		
		if (expression instanceof Negation) {
			Negation negation = (Negation) expression;
			
			if (negation.isNegated()) {
				return DataType.BOOL;
			} else {
				return getDataType(negation.getExpr());
			}
		}
		
		if (expression instanceof Comparison) {
			Comparison comparison = (Comparison) expression;
			
			if (comparison.getRight() != null) {
				return DataType.BOOL;
			} else {
				return getDataType(comparison.getLeft());
			}
		}
		
		if (expression instanceof Addition) {
			Addition addition = (Addition) expression;
			
			DataType leftDataType = getDataType(addition.getLeft());
			
			if (addition.getRight() != null ) {
				DataType rightDataType = getDataType(addition.getRight());
				
				if (leftDataType == DataType.FLOAT || rightDataType == DataType.FLOAT) {
					return DataType.FLOAT;
				} else {
					return DataType.INT;
				}
			} else {
				return leftDataType;
			}
		}
		
		if (expression instanceof AdditiveInversion) {
			return getDataType(expression.getExpr());
		}
		
		if (expression instanceof Multiplication) {
			Multiplication multiplication = (Multiplication) expression;
			
			DataType leftDataType = getDataType(multiplication.getLeft());
			
			if (multiplication.getRight() != null ) {
				DataType rightDataType = getDataType(multiplication.getRight());
				
				if (leftDataType == DataType.FLOAT || rightDataType == DataType.FLOAT) {
					return DataType.FLOAT;
				} else {
					return DataType.INT;
				}
			} else {
				return leftDataType;
			}
		}

		Field field = expression.getFieldRef();
		Expression literal = expression.getLiteral();
		Expression expr = expression.getExpr();
		
		if (field != null) {
			return field.getDataType();
			
		} else if (literal != null) {
			if (literal instanceof BoolLiteral) {
				return DataType.BOOL;
				
			} else if (literal instanceof IntLiteral) {
				return DataType.INT;
				
			} else if (literal instanceof FloatLiteral) {
				return DataType.FLOAT;
				
			} else if (literal instanceof StringLiteral) {
				return DataType.STRING;
			}
		} else  if (expr != null) {
			return getDataType(expr);
		}
		
		return null;
	}
	
	private boolean containsVariable(Expression expression) {
		if (expression == null) {
			return false;
		}
		
		if (expression instanceof Disjunction) {
			Disjunction disjunction = (Disjunction) expression;
			return containsVariable(disjunction.getLeft()) || containsVariable(disjunction.getRight());
		}
		
		if (expression instanceof Conjunction) {
			Conjunction conjunction = (Conjunction) expression;
			return containsVariable(conjunction.getLeft()) || containsVariable(conjunction.getRight());
		}
		
		if (expression instanceof Comparison) {
			Comparison comparison = (Comparison) expression;
			return containsVariable(comparison.getLeft()) || containsVariable(comparison.getRight());
		}
		
		if (expression instanceof Negation) {
			Negation negation = (Negation) expression;
			return containsVariable(negation.getExpr());
		}
		
		Field field = expression.getFieldRef();
		
		if (field != null && field instanceof Variable) {
			return true;
		}
		
		return false;
	}
	
	private List<EObject> fieldsDefinedBefore(Expression expression) {
		KModel kmodel = EcoreUtil2.getContainerOfType(expression, KModel.class);
		List<EObject> contents = EcoreUtil2.eAllContentsAsList(kmodel);
		
		try {
			EObject first = contents
					.stream()
					.filter(field -> EcoreUtil.isAncestor(field, expression))
					.findFirst()
					.get();
			return contents.subList(0 , contents.indexOf(first));
		
		} catch (NoSuchElementException e) {
			return Collections.emptyList();
		}
	}
}
