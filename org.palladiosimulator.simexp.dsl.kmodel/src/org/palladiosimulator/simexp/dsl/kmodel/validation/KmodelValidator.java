/*
 * generated by Xtext 2.26.0
 */
package org.palladiosimulator.simexp.dsl.kmodel.validation;

import org.eclipse.xtext.validation.Check;
import java.util.Collections;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Action;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Array;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.BoolLiteral;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Constant;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.DataType;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Expression;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Field;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.FloatLiteral;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.IntLiteral;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Kmodel;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.KmodelPackage;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Literal;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Operation;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Parameter;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Range;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.RangeWithGrowth;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.Statement;
import org.palladiosimulator.simexp.dsl.kmodel.kmodel.StringLiteral;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class KmodelValidator extends AbstractKmodelValidator {
	
	@Check
	public void checkFieldDeclaredBeforeReference(Expression expression) {
		Field field = expression.getFieldRef();
		
		if (field != null && !fieldDeclaredBefore(field, expression)) {
			String name = field.getName();
			if (name != null) {
				error("Field '" + name + "' must be declared before being referenced.",
						KmodelPackage.Literals.EXPRESSION__FIELD_REF);
			}
		}
	}
	
	@Check
	public void checkConstantValue(Constant constant) {
		Expression value = constant.getValue();
		
		if (containsNonConstantFieldReference(value)) {
			error("Cannot assign an expression containing a variable value to a constant.",
					KmodelPackage.Literals.CONSTANT__VALUE);
			return;
		}
		
		DataType constantDataType = constant.getDataType();
		DataType valueDataType = getDataType(value);
			
		if (!constantDataType.equals(valueDataType)) {
			if (constantDataType == DataType.FLOAT && valueDataType == DataType.INT) {
				return;
			}
				
			error("Expected a value of type '"
					+ constantDataType + "', got '" + valueDataType + "' instead.",
					KmodelPackage.Literals.CONSTANT__VALUE);
		}
	}
	
	@Check
	public void checkValueArray(Array array) {
		DataType dataType = getContainerDataType(array);
		if (dataType == null) {
			return;
		}
		
		List<Expression> values = array.getValues();
		
		for (int i = 0; i < values.size(); i++) {
			Expression value = values.get(i);
			if (containsNonConstantFieldReference(value)) {
				error("A value array may not contain variable values.", KmodelPackage.Literals.ARRAY__VALUES);
				return;
			}
			
			DataType valueType = getDataType(value);
			if (valueType != dataType) {
				if (dataType == DataType.FLOAT && valueType == DataType.INT) {
					continue;
				}
				
				error("Expected only values of type '" + dataType + "', got '" + valueType + "' instead.",
						KmodelPackage.Literals.ARRAY__VALUES);
			}
		}
	}
	
	@Check
	public void checkValueRange(Range range) {
		Expression startValue = range.getStartValue();
		
		if (containsNonConstantFieldReference(startValue)) {
			error("The start value of a range may not contain variable values.", KmodelPackage.Literals.ARRAY__VALUES);
		}
		
		DataType startValueType = getDataType(startValue);
		if (startValueType != DataType.INT && startValueType != DataType.FLOAT) {
			error("Expected a value of type '" + DataType.INT + "' or '" + DataType.FLOAT + "', got '" + startValueType + "' instead.",
					KmodelPackage.Literals.ARRAY__VALUES);
		}
		
		Expression endValue = range.getEndValue();
		
		if (containsNonConstantFieldReference(endValue)) {
			error("The end value of a range may not contain variable values.", KmodelPackage.Literals.ARRAY__VALUES);
		}
		
		DataType endValueType = getDataType(endValue);
		if (endValueType != DataType.INT && endValueType != DataType.FLOAT) {
			error("Expected a value of type '" + DataType.INT + "' or '" + DataType.FLOAT + "', got '" + endValueType + "' instead.",
					KmodelPackage.Literals.ARRAY__VALUES);
		}
		
		Expression stepSize = range.getStepSize();
		
		if (containsNonConstantFieldReference(stepSize)) {
			error("The step size of a range may not contain variable values.", KmodelPackage.Literals.ARRAY__VALUES);
		}
		
		DataType stepSizeType = getDataType(stepSize);
		if (stepSizeType != DataType.INT && stepSizeType != DataType.FLOAT) {
			error("Expected a value of type '" + DataType.INT + "' or '" + DataType.FLOAT + "', got '" + stepSizeType + "' instead.",
					KmodelPackage.Literals.ARRAY__VALUES);
		}
	}
	
	@Check
	public void checkValueRangeWithGrowth(RangeWithGrowth range) {
		Expression startValue = range.getStartValue();
		
		if (containsNonConstantFieldReference(startValue)) {
			error("The start value of a range may not contain variable values.", KmodelPackage.Literals.ARRAY__VALUES);
		}
		
		DataType startValueType = getDataType(startValue);
		if (startValueType != DataType.INT && startValueType != DataType.FLOAT) {
			error("Expected a value of type '" + DataType.INT + "' or '" + DataType.FLOAT + "', got '" + startValueType + "' instead.",
					KmodelPackage.Literals.ARRAY__VALUES);
		}
		
		Expression endValue = range.getEndValue();
		
		if (containsNonConstantFieldReference(endValue)) {
			error("The end value of a range may not contain variable values.", KmodelPackage.Literals.ARRAY__VALUES);
		}
		
		DataType endValueType = getDataType(endValue);
		if (endValueType != DataType.INT && endValueType != DataType.FLOAT) {
			error("Expected a value of type '" + DataType.INT + "' or '" + DataType.FLOAT + "', got '" + endValueType + "' instead.",
					KmodelPackage.Literals.ARRAY__VALUES);
		}
		
		Expression stepSize = range.getNumSteps();
		
		if (containsNonConstantFieldReference(stepSize)) {
			error("The step size of a range may not contain variable values.", KmodelPackage.Literals.ARRAY__VALUES);
		}
		
		DataType stepSizeType = getDataType(stepSize);
		if (stepSizeType != DataType.INT) {
			error("Expected a value of type '" + DataType.INT  + "', got '" + stepSizeType + "' instead.",
					KmodelPackage.Literals.ARRAY__VALUES);
		}
	}
	
	@Check
	public void checkCondition(Statement ifStatement) {
		Expression condition = ifStatement.getCondition();

		DataType conditionType = getDataType(condition);
			
		if (!conditionType.equals(DataType.BOOL)) {
			error("Expected a value of type '" + DataType.BOOL 
					+ "', got '" + conditionType + "' instead.",
					KmodelPackage.Literals.STATEMENT__CONDITION);
		}
	}
	
	@Check
	public void checkParameterOrder(Action action) {
		List<Parameter> parameters = action.getParameters();
		
		boolean foundVar = false;
		
		for (Parameter parameter : parameters) {
			if (foundVar && !parameter.isVar()) {
				error("Variable parameters must be listed at the end.", KmodelPackage.Literals.ACTION__PARAMETERS);
				return;
			}
			
			if (!foundVar && parameter.isVar()) {
				foundVar = true;
			}
		}
	}
	
	@Check
	public void checkArguments(Statement actionCall) {
		Action action = actionCall.getActionRef();
		List<Expression> arguments = actionCall.getArguments();
		List<Parameter> parameters = action.getParameters();
		
		List<Parameter> argumentableParameters = parameters
				.stream()
				.filter(Predicate.not(Parameter::isVar))
				.collect(Collectors.toList());
		
		if (arguments.size() != argumentableParameters.size()) {
			error("Expected " + argumentableParameters.size() + " arguments, got " + arguments.size() + ".", 
					KmodelPackage.Literals.STATEMENT__ARGUMENTS);
			return;
		}
		
		String parameterTypes = argumentableParameters
				.stream()
				.map(param -> param.getDataType().toString())
				.collect(Collectors.joining(", ", "(", ")"));
		String argumentTypes = arguments
				.stream()
				.map(arg -> getDataType(arg).toString())
				.collect(Collectors.joining(", ", "(", ")"));
		
		if (!parameterTypes.equals(argumentTypes)) {
			error("Expected arguments of types " + parameterTypes + ", got " + argumentTypes + " instead.",
					KmodelPackage.Literals.STATEMENT__ARGUMENTS);
		}
	}
	
	@Check
	public void checkExpressions(Expression expression) {
		DataType leftDataType = getDataType(expression.getLeft());
		DataType rightDataType = getDataType(expression.getRight());
		
		boolean leftIsNumber = leftDataType == DataType.INT || leftDataType == DataType.FLOAT;
		boolean rightIsNumber = rightDataType == DataType.INT || rightDataType == DataType.FLOAT;
		
		Operation operation = expression.getOp();

		switch(operation) {
			case NULL:
				return;
					
			case OR:
			case AND:
			case NOT:	
				if (leftDataType != DataType.BOOL) {
					error("Expected a value of type '" + DataType.BOOL + "', got '" + leftDataType + "' instead.", 
							KmodelPackage.Literals.EXPRESSION__LEFT);
				}
				
				if (rightDataType != null && rightDataType != DataType.BOOL) {
					error("Expected a value of type '" + DataType.BOOL + "', got '" + rightDataType + "' instead.", 
							KmodelPackage.Literals.EXPRESSION__RIGHT);
				}
				return;
				
			case EQUAL:
			case UNEQUAL:
				if (!(leftIsNumber && rightIsNumber) && leftDataType != rightDataType) {
					error("Cannot compare the equality of a '"
							+ leftDataType + "' value with a '" + rightDataType + "' value.",
							KmodelPackage.Literals.EXPRESSION__LEFT);
					
					error("Cannot compare the equality of a '"
							+ leftDataType + "' value with a '" + rightDataType + "' value.",
							KmodelPackage.Literals.EXPRESSION__RIGHT);
				}
				return;
				
			case SMALLER:
			case SMALLER_OR_EQUAL:
			case GREATER_OR_EQUAL:
			case GREATER:
			case PLUS:
			case MINUS:
			case MULTIPLY:
			case DIVIDE:
				if (!leftIsNumber) {
					error("Expected a value of type '" + DataType.INT + "' or '" + DataType.FLOAT + "', got '" + leftDataType + "' instead.",
							KmodelPackage.Literals.EXPRESSION__LEFT);
				}
				
				if (rightDataType != null && !rightIsNumber) {
					error("Expected a value of type '" + DataType.INT + "' or '" + DataType.FLOAT + "', got '" + rightDataType + "' instead.",
							KmodelPackage.Literals.EXPRESSION__LEFT);
				}
		}
	}
	
	/*
	 * Returns the datatype of an expression
	 */
	private DataType getDataType(Expression expression) {
		if (expression == null) {
			return null;
		}
		
		Operation operation = expression.getOp();
		switch (operation) {
			// No Operation.
			case NULL:
				break;
			
			// Fallthrough, all cases are boolean.
			case OR:
			case AND:
			case EQUAL:
			case UNEQUAL:
			case NOT:	
			case SMALLER:
			case SMALLER_OR_EQUAL:
			case GREATER_OR_EQUAL:
			case GREATER:	
				return DataType.BOOL;
			
			// Fallthrough, all cases are either int or float.
			case PLUS:
			case MINUS:
			case MULTIPLY:
				DataType leftDataType = getDataType(expression.getLeft());
				DataType rightDataType = getDataType(expression.getRight());
				
				if (leftDataType == DataType.FLOAT || rightDataType == DataType.FLOAT) {
					return DataType.FLOAT;
				} else {
				return DataType.INT;
				}
				
			// Division returns always a float value.	
			case DIVIDE:
				return DataType.FLOAT;
				
			default: 
				break;	
		}
		
		Expression left = expression.getLeft();
		if (left != null) {
			return getDataType(left);
		}
		
		Literal literal = expression.getLiteral();
		if (literal != null) {
			if (literal instanceof BoolLiteral) {
				return DataType.BOOL;
				
			} else if (literal instanceof IntLiteral) {
				return DataType.INT;
				
			} else if (literal instanceof FloatLiteral) {
				return DataType.FLOAT;
				
			} else if (literal instanceof StringLiteral) {
				return DataType.STRING;
			}
		}
		
		Field fieldRef = expression.getFieldRef();
		return fieldRef != null ? fieldRef.getDataType() : null;
	}
	
	/*
	 * Returns true iff the expression contains a field reference to a non-constant value.
	 */
	private boolean containsNonConstantFieldReference(Expression expression) {
		if (expression == null) {
			return false;
		}
		
		Expression leftExpr = expression.getLeft();
		Expression rightExpr = expression.getRight();
		if (leftExpr != null) {
			if (rightExpr != null) {
				return containsNonConstantFieldReference(leftExpr) 
						|| containsNonConstantFieldReference(rightExpr);
			}
			
			return containsNonConstantFieldReference(leftExpr);
		}
		
		Field field = expression.getFieldRef();
		return field != null && !(field instanceof Constant);
	}
	
	/*
	 * Returns true iff the field was declared before beeing referenced in the expression.
	 */
	private boolean fieldDeclaredBefore(Field field, Expression expression) {
		Kmodel kmodel = EcoreUtil2.getContainerOfType(expression, Kmodel.class);
		List<EObject> contents = EcoreUtil2.eAllContentsAsList(kmodel);
		List<EObject> fieldsDefinedBefore;
		
		try {
			EObject first = contents
					.stream()
					.filter(object -> EcoreUtil.isAncestor(object, expression))
					.findFirst()
					.get();
			fieldsDefinedBefore = contents.subList(0 , contents.indexOf(first));
		
		} catch (NoSuchElementException e) {
			fieldsDefinedBefore = Collections.emptyList();
		}
		
		return fieldsDefinedBefore.contains(field);
	}
	
	private DataType getContainerDataType(EObject object) {
		EObject container = object.eContainer();
		
		if (container == null) {
			return null;
		}
		
		if (container instanceof Field) {
			return ((Field) container).getDataType();
		}
		
		if (container instanceof Parameter) {
			return ((Parameter) container).getDataType();
		}
		
		return null;
	}
}
